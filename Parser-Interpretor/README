-- Buica Mihai Victoras, 322CB, Tema1_PP
-- punctaj local: 108 puncte.

=======TASK 1=======
Pentru rezolvarea primului task, am definit ClassState (containterul) ca fiind o lista de tupluri de tipul : (InstrType, [String]). Primul element reprezinta tipul: Var/Func(instructiunea) iar [String] reprezinta lista de parametrii(pentru o variabila: numele si tipul, pentru functie: nume, tip intors, parametrii).
-insertIntoClass: functe ce adauga o instructiune in containerul unei clase. Se creeaza tuplul format din (tipul instructiunii, parametrii) si se adauga in containerul de clasa.
-getValues: functie ce returneaza valorile de un anumit tip dintr-un container. Functia se foloseste de foldl si de printInfo. printInfo este o functie ce primeste tipul unei instructiuni, o lista acumulator si un element din containerul unei clase. In cazul in care elementul respectiv este de tipul primit ca parametru, acesta este adaugat in acumulator, altfel este ignorat. Folosind aceasta functie si foldl, fiecare element din classState este preluat si prelucrat, la final, in lista acumulator aflandu-se doar elementele de tipul primit de getValues. 

=======TASK 2=======
Program a fost definit ca fiind o lista de tupluri de tipul: (String, String, ClassState), ce reprezinta: (Numele clasei, Numele parintelui, Containerul clasei). 
Intructiunea a fost definita ca fiind un tuplu de tipul: (String, [String]), ce reprezinta (Numele instructiunii, [Elementele(paremetrii) instructiunii]), de exemplu pentru o variabila va arata de tipul: (newvar, ["a","Int"]). Primul element va fi folosit pentru a se identifica tipul comenzii, in timp ce al doilea element al tuplului va fi folosit pentru a creea variabila/clasa/functia.
	==PARSARE==
	Pentru realizarea parsarii, am folosit mai multe functii auxiliare:
	-splitBy: functia primeste un delimitator si un string si sparge stringul in fuctie de acel delimitator. Stringul este parcurs caracter cu caracter, in cazul in care carecterul este idetificat ca fiind un delimitator, acesta este eliminat. Inconvenientul acestei functii este ca atunci cand exista doi delimitatori consecutivi, in lista finala apar stringuri vide.(functia este preluata din curs - cursul 5).
	-splitBy2: avand numele asemanator si functionalitatea este la fel ca cea de mai sus. Diferenta consta ca aceasta functie sparge string-ul in functie de o lista de delimitatori(ex: ' ', ':' etc.)
	-contains: functie folosita de splitBy2 pentru a determina daca un caracter este delimitator. Functia cauta un caracter intr-o lista de caractere.
	-rmvEmpty: pentru a rezolva inconvenientul produs de splitBy(stringurile vide din interiorul listei finale) fiecare rezultat intrs de splitBy este prelucrat de aceasta functie. Ea verifica daca intr-o lista de stringuri exista un string vid, iar in caz afirmativ, il elimina returnand lista finala ce urmeaza sa fie transformata in instructiune.
	-transform: Parsarea se face pe tot fisierul, deci pe mai multe comenzi. Fiecare comanda(fiecare rand) va fi reprezentata printr-o [String]. Aceasta functie transforma fiecare lista intr-o instructiune. Instructiunea fiind reprezentata printr-un tuplu, functia creeaza tuplul format din (primul element din lista, restul listei), reprezentand: (numele instructiunii, setul de parametrii ai instructiunii). Prelucrand fiecare rand din fisier in acest fel, se obtine o lista de instructiuni.
	-PARSE: in prima faza, se face parsarea dupa '\n', delimitandu-se astfel comenzile una de cealalta. Apoi, fiecare string ce a rezultat din prima parsare, este parsat dupa setul de delimitatori(tokens) rezultand asfel o lista de stringuri ce contine: numele comenzii(class, newvar, infer) : lista de parametrii (nume, tip/tip intors, pentru clase: parinte, etc.). Aceasta lista de stringuri este apoi data functiei transform si se transforma in instructiuni: tuplu de forma (nume comanda, [lista de paremetrii]). 
	
	==INTERPRETARE==
	Pentru realizarea interpretarii, functia ~interpret~ identifica tipul instructiunii dupa nume(in cazul in care nu este un keyword, inseamna ca se doreste sa se creeze o noua functie) si apeleaza functia specifica fiecarei instructiuni:
	-initClass: functie pentru crearea de clase. In cazul in care exista deja acea clasa in program nu este creata una noua, daca exista si programul este unul gol, se adauga clasa "Global" si noua clasa in program, iar daca programul era deja initializat, doar se adauga in program. Exista doua variante, in care clasa are numele parintelui specificat, iar atunci se verifica si acesta si se adauga, sau cand nu este specificat si atunci se adauga cu parintele default("Global"). In cazul in care structura este diferita, se ignora acea linie.
	-initNewVar: functie pentru crearea unei variabile. Se verifica daca clasa din care face parte variabila exista in program, iar in caz afirmativ, in containerul clasei "Global" se adauga o noua intrare de tip "Var" cu numele si tipul clasei primit.
	-initFunc: functie pentru creare unei noi functii. Se verifica daca exista clasa returnata, clasa din care face parte si daca exista parametrii pe care ii primeste functia. In caz afirmativ se creeaza o noua intrare de tip "Func" in containerul clasei din care face parte functia. 
	-verifyExistClass/verifyExistClassList: functii ce primesc un nume de clasa/nume de clasa + parametrii si verifica in tot programul daca exista clasa respectiva.
	-addInProgCS: functie ce primeste un nume de clasa si un element si adauga elementul in containerul clasei primite ca paremetru. element = Var/Func. Adauga o variabila/ o functie intr-o clasa, al carei nume este primit ca parametru.
Pentru implementarea functiilor necesare testarii, am folosit functiile implementate la punctul a.
-getVars: functia returneaza variabilele din program(ele sunt stocate in containerul clasei "Global"). Pentru asta, este folosita functia getValues de la punctul a, pentru instrunctiuni de tipul Var.
-getClasses: pentru fiecare clasa din program, este retinut numele ei.
-getParentClass: este cautata clasa cu numele primit ca parametru, iar din strunctura programului se returneaza numele parintelui(el era deja stocat separat ca un element al tuplului).
-getFuncsForClass: este cautata clasa cu numele primit ca paremetru, iar cu ajutorul functiei getValues sunt returnate toate valorile de tip Func din containerul clasei respective.

=======TASK 3=======
Functia ce realizeaza inferentei de tip pentru o expresie este functia infer. In mare, ea verifica pentru fiecare element primit daca acesta exista si daca tipul lui coincide cu tipul din program. Pentru cautare, am definit functii ce vor fi explicate mai jos. Daca elementul este o variabila atunci se verifica existenta ei in program, iar daca exista se intoarce tipul ei (este un Maybe). In cazul in care este o functie, se verifica daca numele functiei impreuna cu lista de parametrii exista in program. Pentru verificarea unei functii, este nevoie sa construim lista ei de parametrii, asadar, pentru fiecare parametru trebuie sa apelam infer si sa extragem string-ul intors (de asta se ocupa functia preculrareParam: apeleaza infer pentru fiecare parametru si construieste lista de parametrii necesara verificarii). Dupa ce lista de parametrii a fost construita, se concateneaza numele functiei si se poate verifica daca aceasta exista in program. In cazul in care vreo inferenta esueaza, este intors Nothing. 
Functiile de verificare (verifiFunc, verfyExistFunc, verifiExist) sunt in mare parte asemanatoare cu cele de la punctul precedent, doar ca acestea intorc tipul variabilei/functiei cautate sau Nothing in caz ca nu exista. Deoarece tipul intors este cel ce trebuie returnat de functie, la comparatii, acesta nu este luat in considerare(asadar pentru ca doua functii sa fie egale, trebuie sa aiba acelasi nume si aceeasi parametrii=> din asta deduc tipul intors).

=======BONUS=======
Pentru rezolvarea(partiala) a bonusului, am abordat aceeasi strategie ca la punctul precedent. De data aceasta, apare un delimitator nou: '.', dupa care se face parsare. Comanda este identificata cu cuvantul cheie "infer". Se creeaza o noua variabila cu tipul dat in urma inferentei de tip a parametriilor primiti. Fiecare parametru este transformat intr-o Expr pentru a se putea aplica functia infer asupra lui. 